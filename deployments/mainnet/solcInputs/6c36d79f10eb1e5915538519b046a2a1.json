{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/liquidation/magicians/_common/libraries/CrvUSDToWethViaTriCrvPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/ICurvePoolLike256WithReturn.sol\";\n\n/// @dev Curve pool exchange\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\nlibrary CrvUSDToWethViaTriCrvPoolLib {\n    uint256 constant public WETH_INDEX = 1;\n    uint256 constant public CRV_USD_INDEX = 0;\n\n    uint256 constant public UNKNOWN_AMOUNT = 1;\n\n    function crvUsdToWethViaTriCrv(\n        uint256 _amount,\n        address _pool,\n        IERC20 _crvUsd\n    )\n        internal\n        returns (uint256 receivedWeth)\n    {\n        _crvUsd.approve(_pool, _amount);\n\n        receivedWeth = ICurvePoolLike256WithReturn(_pool).exchange(\n            CRV_USD_INDEX,\n            WETH_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n\n    function wethToCrvUsdViaTriCrv(\n        uint256 _amount,\n        address _pool,\n        IERC20 _weth\n    )\n        internal\n        returns (uint256 receivedCrv)\n    {\n        _weth.approve(_pool, _amount);\n\n        receivedCrv = ICurvePoolLike256WithReturn(_pool).exchange(\n            WETH_INDEX,\n            CRV_USD_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n}\n"
    },
    "contracts/liquidation/magicians/_common/libraries/FraxUsdcPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/ICurvePoolLike128WithReturn.sol\";\n\n/// @dev Curve pool exchange\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\nlibrary FraxUsdcPoolLib {\n    int128 constant public FRAX_INDEX = 0;\n    int128 constant public USDC_INDEX = 1;\n\n    uint256 constant public UNKNOWN_AMOUNT = 1;\n\n    function fraxToUsdcViaCurve(uint256 _amount, address _pool, IERC20 _frax) internal returns (uint256) {\n        _frax.approve(_pool, _amount);\n\n        return ICurvePoolLike128WithReturn(_pool).exchange(\n            FRAX_INDEX,\n            USDC_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n\n    function usdcToFraxViaCurve(uint256 _amount, address _pool, IERC20 _usdc) internal returns (uint256) {\n        _usdc.approve(_pool, _amount);\n\n        return ICurvePoolLike128WithReturn(_pool).exchange(\n            USDC_INDEX,\n            FRAX_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n}\n"
    },
    "contracts/liquidation/magicians/_common/libraries/SdaiFraxPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/ICurvePoolLike128WithReturn.sol\";\n\n/// @dev Curve pool exchange\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\nlibrary SdaiFraxPoolLib {\n    int128 constant public FRAX_INDEX = 0;\n    int128 constant public SDAI_INDEX = 1;\n\n    uint256 constant public UNKNOWN_AMOUNT = 1;\n\n    function sdaiToFraxViaCurve(uint256 _amount, address _pool, IERC20 _sDAI) internal returns (uint256 receivedWeth) {\n        _sDAI.approve(_pool, _amount);\n\n        receivedWeth = ICurvePoolLike128WithReturn(_pool).exchange(\n            SDAI_INDEX,\n            FRAX_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n\n    function fraxToSdaiViaCurve(uint256 _amount, address _pool, IERC20 _frax) internal returns (uint256 receivedCrv) {\n        _frax.approve(_pool, _amount);\n\n        receivedCrv = ICurvePoolLike128WithReturn(_pool).exchange(\n            FRAX_INDEX,\n            SDAI_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n}\n"
    },
    "contracts/liquidation/magicians/_common/libraries/SdaiSusdePoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/ICurvePoolLike128WithReturn.sol\";\n\n/// @dev Curve pool exchange\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\nlibrary SdaiSusdePoolLib {\n    int128 constant public SDAI_INDEX = 0;\n    int128 constant public SUSDE_INDEX = 1;\n\n    uint256 constant public UNKNOWN_AMOUNT = 1;\n\n    function susdeToSdaiViaCurve(\n        uint256 _amount,\n        address _pool,\n        IERC20 _sUSDe\n    ) internal returns (uint256 receivedWeth) {\n        _sUSDe.approve(_pool, _amount);\n\n        receivedWeth = ICurvePoolLike128WithReturn(_pool).exchange(\n            SUSDE_INDEX,\n            SDAI_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n\n    function sdaiToSusdeViaCurve(uint256 _amount, address _pool, IERC20 _sDAI) internal returns (uint256 receivedCrv) {\n        _sDAI.approve(_pool, _amount);\n\n        receivedCrv = ICurvePoolLike128WithReturn(_pool).exchange(\n            SDAI_INDEX,\n            SUSDE_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n}\n"
    },
    "contracts/liquidation/magicians/_common/libraries/UsdcCrvUsdcPoolLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/ICurvePoolLike128WithReturn.sol\";\n\n/// @dev Curve pool exchange\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\nlibrary UsdcCrvUsdcPoolLib {\n    int128 constant public USDC_INDEX = 0;\n    int128 constant public CRV_USD_INDEX = 1;\n\n    uint256 constant public UNKNOWN_AMOUNT = 1;\n\n    function usdcToCrvUsdViaCurve(uint256 _amount, address _pool, IERC20 _usdc) internal returns (uint256) {\n        _usdc.approve(_pool, _amount);\n\n        return ICurvePoolLike128WithReturn(_pool).exchange(\n            USDC_INDEX,\n            CRV_USD_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n\n    function crvUsdToUsdcViaCurve(uint256 _amount, address _pool, IERC20 _crvUsd) internal returns (uint256) {\n        _crvUsd.approve(_pool, _amount);\n\n        return ICurvePoolLike128WithReturn(_pool).exchange(\n            CRV_USD_INDEX,\n            USDC_INDEX,\n            _amount,\n            UNKNOWN_AMOUNT\n        );\n    }\n}\n"
    },
    "contracts/liquidation/magicians/interfaces/ICurvePoolLike128WithReturn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface ICurvePoolLike128WithReturn {\n    // solhint-disable func-name-mixedcase\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minDy) external returns (uint256);\n    function remove_liquidity_one_coin(uint256 amount, int128 i, uint256 minDy) external returns (uint256);\n    function exchange_underlying(int128 _i, int128 _j, uint256 _dx, uint256 _minDy) external returns (uint256);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    // solhint-enable func-name-mixedcase\n}\n"
    },
    "contracts/liquidation/magicians/interfaces/ICurvePoolLike256WithReturn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ninterface ICurvePoolLike256WithReturn {\n    // solhint-disable func-name-mixedcase\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 minDy) external returns (uint256);\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n    // solhint-enable func-name-mixedcase\n}\n"
    },
    "contracts/liquidation/magicians/interfaces/IMagician.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9.0;\n\n/// @notice Extension for the Liquidation helper to support such operations as unwrapping\ninterface IMagician {\n    /// @notice Operates to unwrap an `_asset`\n    /// @param _asset Asset to be unwrapped\n    /// @param _amount Amount of the `_asset`\n    /// @return tokenOut A token that the `_asset` has been converted to\n    /// @return amountOut Amount of the `tokenOut` that we received\n    function towardsNative(address _asset, uint256 _amount) external returns (address tokenOut, uint256 amountOut);\n\n    /// @notice Performs operation opposit to `towardsNative`\n    /// @param _asset Asset to be wrapped\n    /// @param _amount Amount of the `_asset`\n    /// @return tokenOut A token that the `_asset` has been converted to\n    /// @return amountOut Amount of the quote token that we spent to get `_amoun` of the `_asset`\n    function towardsAsset(address _asset, uint256 _amount) external returns (address tokenOut, uint256 amountOut);\n}\n"
    },
    "contracts/liquidation/magicians/sUSDe/SUSDeViaCurveMaigicianEth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IMagician.sol\";\nimport \"../_common/libraries/FraxUsdcPoolLib.sol\";\nimport \"../_common/libraries/SdaiFraxPoolLib.sol\";\nimport \"../_common/libraries/SdaiSusdePoolLib.sol\";\nimport \"../_common/libraries/UsdcCrvUsdcPoolLib.sol\";\nimport \"../_common/libraries/CrvUSDToWethViaTriCrvPoolLib.sol\";\n\n/// @dev sUSDe Magician\n/// IT IS NOT PART OF THE PROTOCOL. SILO CREATED THIS TOOL, MOSTLY AS AN EXAMPLE.\ncontract SUSDeViaCurveMaigicianEth is IMagician {\n    using FraxUsdcPoolLib for uint256;\n    using SdaiFraxPoolLib for uint256;\n    using SdaiSusdePoolLib for uint256;\n    using UsdcCrvUsdcPoolLib for uint256;\n    using CrvUSDToWethViaTriCrvPoolLib for uint256;\n\n    IERC20 public constant SUSDE = IERC20(0x9D39A5DE30e57443BfF2A8307A4256c8797A3497);\n    IERC20 public constant SDAI = IERC20(0x83F20F44975D03b1b09e64809B757c47f942BEeA);\n    IERC20 public constant FRAX = IERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);\n    IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 public constant CRV_USD = IERC20(0xf939E0A03FB07F59A73314E73794Be0E57ac1b4E);\n\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address public constant SDAI_FRAX_POOL = 0xcE6431D21E3fb1036CE9973a3312368ED96F5CE7;\n    address public constant USDC_CRV_USD_POOOL = 0x4DEcE678ceceb27446b35C672dC7d61F30bAD69E;\n    address public constant FRX_USDC_POOL = 0xDcEF968d416a41Cdac0ED8702fAC8128A64241A2;\n    address public constant SDAI_SUSDE_POOL = 0x167478921b907422F8E88B43C4Af2B8BEa278d3A;\n    address public constant TRI_CRV_POOL = 0x4eBdF703948ddCEA3B11f675B4D1Fba9d2414A14;\n\n    error Unsupported();\n\n    /// @inheritdoc IMagician\n    function towardsNative(\n        address _asset,\n        uint256 _amount\n    )\n        external\n        virtual\n        returns (address tokenOut, uint256 amountOut)\n    {\n        if (_asset != address(SUSDE)) revert Unsupported();\n\n        tokenOut = address(WETH);\n\n        amountOut;\n\n        {\n            amountOut = _amount\n                .susdeToSdaiViaCurve(SDAI_SUSDE_POOL, SUSDE)\n                .sdaiToFraxViaCurve(SDAI_FRAX_POOL, SDAI)\n                .fraxToUsdcViaCurve(FRX_USDC_POOL, FRAX)\n                .usdcToCrvUsdViaCurve(USDC_CRV_USD_POOOL, USDC);\n        }\n\n        amountOut = amountOut.crvUsdToWethViaTriCrv(TRI_CRV_POOL, CRV_USD);\n    }\n\n    /// @dev As Curve LP Tokens can be collateral-only assets we skip the implementation of this function\n    function towardsAsset(address, uint256) external virtual pure returns (address, uint256) {\n        revert Unsupported();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}